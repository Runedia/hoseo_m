const cheerio = require("cheerio");
const fs = require("fs-extra");
const path = require("path");

const INPUT_HTML = path.resolve(process.cwd(), "assets", "í•™ì‚¬ì¼ì •.html");
const OUTPUT_JSON = path.resolve(process.cwd(), "assets", "í•™ì‚¬ì¼ì •.json");

// ë‚ ì§œ íŒŒì‹± í•¨ìˆ˜
function parseDate(dateStr, year = 2025) {
  // "2(ëª©)", "6(ì›”) ~ 10(ê¸ˆ)", "2026.1ì›”" ë“±ì˜ í˜•íƒœ ì²˜ë¦¬
  dateStr = dateStr.trim();
  
  // 2026ë…„ í˜•íƒœ ì²˜ë¦¬
  if (dateStr.includes("2026")) {
    year = 2026;
    dateStr = dateStr.replace("2026.", "");
  }
  
  const results = [];
  
  // ê¸°ê°„ í˜•íƒœ (6(ì›”) ~ 10(ê¸ˆ), 23(ì›”) ~ 7. 11.(ê¸ˆ) ë“±)
  if (dateStr.includes("~")) {
    const [startPart, endPart] = dateStr.split("~").map(s => s.trim());
    
    // ì‹œì‘ì¼ íŒŒì‹±
    const startMatch = startPart.match(/(\d+)\([^)]+\)/);
    if (startMatch) {
      const startDay = parseInt(startMatch[1]);
      
      // ì¢…ë£Œì¼ íŒŒì‹±
      let endDay, endMonth;
      
      // "7. 11.(ê¸ˆ)" í˜•íƒœ (ë‹¤ë¥¸ ë‹¬ë¡œ ë„˜ì–´ê°€ëŠ” ê²½ìš°)
      const crossMonthMatch = endPart.match(/(\d+)\.\s*(\d+)\.\([^)]+\)/);
      if (crossMonthMatch) {
        endMonth = parseInt(crossMonthMatch[1]);
        endDay = parseInt(crossMonthMatch[2]);
      } else {
        // ê°™ì€ ë‹¬ ë‚´ ì¢…ë£Œì¼
        const endMatch = endPart.match(/(\d+)\([^)]+\)/);
        if (endMatch) {
          endDay = parseInt(endMatch[1]);
          endMonth = null; // ê°™ì€ ë‹¬
        }
      }
      
      // ë‚ ì§œ ë²”ìœ„ ìƒì„±
      if (endDay) {
        const currentMonth = getCurrentMonth(dateStr);
        const targetEndMonth = endMonth || currentMonth;
        
        if (endMonth && endMonth !== currentMonth) {
          // ë‹¤ë¥¸ ë‹¬ë¡œ ë„˜ì–´ê°€ëŠ” ê²½ìš°
          // í˜„ì¬ ë‹¬ì˜ ë§ˆì§€ë§‰ ë‚ ê¹Œì§€
          const daysInCurrentMonth = getDaysInMonth(year, currentMonth);
          for (let day = startDay; day <= daysInCurrentMonth; day++) {
            results.push(formatDate(year, currentMonth, day));
          }
          // ë‹¤ìŒ ë‹¬ 1ì¼ë¶€í„° ì¢…ë£Œì¼ê¹Œì§€
          for (let day = 1; day <= endDay; day++) {
            results.push(formatDate(year, targetEndMonth, day));
          }
        } else {
          // ê°™ì€ ë‹¬ ë‚´
          for (let day = startDay; day <= endDay; day++) {
            results.push(formatDate(year, currentMonth, day));
          }
        }
      }
    }
  } else {
    // ë‹¨ì¼ ë‚ ì§œ (2(ëª©), 20(ëª©) ë“±)
    const singleMatch = dateStr.match(/(\d+)\([^)]+\)/);
    if (singleMatch) {
      const day = parseInt(singleMatch[1]);
      const month = getCurrentMonth(dateStr);
      results.push(formatDate(year, month, day));
    }
  }
  
  return results;
}

// í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ì›” (ì „ì—­ ë³€ìˆ˜ë¡œ ê´€ë¦¬)
let currentProcessingMonth = 1;

function getCurrentMonth(dateStr) {
  // ì»¨í…ìŠ¤íŠ¸ì—ì„œ í˜„ì¬ ì›” ë°˜í™˜
  return currentProcessingMonth;
}

function getDaysInMonth(year, month) {
  return new Date(year, month, 0).getDate();
}

function formatDate(year, month, day) {
  return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
}

// ì›” ì´ë¦„ì„ ìˆ«ìë¡œ ë³€í™˜
function getMonthNumber(monthText) {
  const monthMap = {
    "1ì›”": 1, "2ì›”": 2, "3ì›”": 3, "4ì›”": 4, "5ì›”": 5, "6ì›”": 6,
    "7ì›”": 7, "8ì›”": 8, "9ì›”": 9, "10ì›”": 10, "11ì›”": 11, "12ì›”": 12,
    "January": 1, "February": 2, "March": 3, "April": 4, "May": 5, "June": 6,
    "July": 7, "August": 8, "September": 9, "October": 10, "November": 11, "December": 12
  };
  
  // "2026.1ì›”" í˜•íƒœ ì²˜ë¦¬
  if (monthText.includes("2026")) {
    const match = monthText.match(/(\d+)ì›”/);
    return match ? parseInt(match[1]) : 1;
  }
  
  return monthMap[monthText] || 1;
}

// ë©”ì¸ íŒŒì‹± í•¨ìˆ˜
async function parseCalendarToJson() {
  try {
    console.log("ğŸ“… í•™ì‚¬ì¼ì • HTML íŒŒì‹± ì‹œì‘...");
    
    // 1. HTML íŒŒì¼ ì½ê¸°
    if (!fs.existsSync(INPUT_HTML)) {
      throw new Error(`í•™ì‚¬ì¼ì • HTML íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${INPUT_HTML}`);
    }
    
    const htmlContent = fs.readFileSync(INPUT_HTML, "utf-8");
    const $ = cheerio.load(htmlContent);
    
    // 2. í•™ì‚¬ì¼ì • ë°ì´í„° êµ¬ì¡°
    const calendarData = {
      title: "í˜¸ì„œëŒ€í•™êµ 2025í•™ë…„ë„ í•™ì‚¬ì¼ì •",
      generatedAt: new Date().toISOString(),
      events: []
    };
    
    // 3. ê° ì›”ë³„ ì¼ì • íŒŒì‹±
    $('#academic_scd01 ul > li').each((index, element) => {
      const $li = $(element);
      
      // ì›” ì •ë³´ ì¶”ì¶œ
      const monthText = $li.find('.box-month').text().trim();
      currentProcessingMonth = getMonthNumber(monthText);
      
      console.log(`ğŸ“Œ ${monthText} ì²˜ë¦¬ ì¤‘...`);
      
      // í•´ë‹¹ ì›”ì˜ ì¼ì •ë“¤ ì²˜ë¦¬
      $li.find('.list-box').each((i, listBox) => {
        const $box = $(listBox);
        const dateText = $box.find('.list-date em').text().trim();
        const eventText = $box.find('.list-content').text().trim();
        
        if (dateText && eventText) {
          // ë‚ ì§œ íŒŒì‹±
          const dates = parseDate(dateText, monthText.includes("2026") ? 2026 : 2025);
          
          // ê° ë‚ ì§œì— ëŒ€í•´ ì´ë²¤íŠ¸ ì¶”ê°€
          dates.forEach(date => {
            calendarData.events.push({
              date: date,
              dateOriginal: dateText,
              event: eventText,
              month: monthText,
              monthNumber: currentProcessingMonth,
              year: monthText.includes("2026") ? 2026 : 2025
            });
          });
          
          console.log(`  âœ… ${dateText} â†’ ${eventText} (${dates.length}ê°œ ë‚ ì§œ)`);
        }
      });
    });
    
    // 4. ë‚ ì§œìˆœ ì •ë ¬
    calendarData.events.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    // 5. í†µê³„ ì •ë³´ ì¶”ê°€
    calendarData.statistics = {
      totalEvents: calendarData.events.length,
      eventsByMonth: {},
      dateRange: {
        start: calendarData.events[0]?.date || null,
        end: calendarData.events[calendarData.events.length - 1]?.date || null
      }
    };
    
    // ì›”ë³„ ì´ë²¤íŠ¸ ìˆ˜ ê³„ì‚°
    calendarData.events.forEach(event => {
      const monthKey = `${event.year}-${String(event.monthNumber).padStart(2, '0')}`;
      calendarData.statistics.eventsByMonth[monthKey] = 
        (calendarData.statistics.eventsByMonth[monthKey] || 0) + 1;
    });
    
    // 6. JSON íŒŒì¼ë¡œ ì €ì¥
    await fs.writeFile(OUTPUT_JSON, JSON.stringify(calendarData, null, 2), "utf-8");
    
    console.log("\\nğŸ‰ í•™ì‚¬ì¼ì • JSON ë³€í™˜ ì™„ë£Œ!");
    console.log(`ğŸ“ ì €ì¥ ìœ„ì¹˜: ${OUTPUT_JSON}`);
    console.log(`ğŸ“Š ì´ ì´ë²¤íŠ¸ ìˆ˜: ${calendarData.statistics.totalEvents}ê°œ`);
    console.log(`ğŸ“… ê¸°ê°„: ${calendarData.statistics.dateRange.start} ~ ${calendarData.statistics.dateRange.end}`);
    
    // 7. ìƒ˜í”Œ ë°ì´í„° ì¶œë ¥
    console.log("\\nğŸ“‹ ìƒ˜í”Œ ë°ì´í„°:");
    calendarData.events.slice(0, 5).forEach(event => {
      console.log(`  ${event.date} - ${event.event}`);
    });
    
    return calendarData;
    
  } catch (error) {
    console.error("âŒ ì˜¤ë¥˜ ë°œìƒ:", error.message);
    console.error(error.stack);
    throw error;
  }
}

// ë‚ ì§œë³„ ì¡°íšŒë¥¼ ìœ„í•œ í—¬í¼ í•¨ìˆ˜ë“¤ë„ ìƒì„±
async function generateHelperFunctions() {
  try {
    const calendarData = JSON.parse(fs.readFileSync(OUTPUT_JSON, "utf-8"));
    
    // ë‚ ì§œë³„ ì¸ë±ìŠ¤ ìƒì„±
    const dateIndex = {};
    calendarData.events.forEach(event => {
      if (!dateIndex[event.date]) {
        dateIndex[event.date] = [];
      }
      dateIndex[event.date].push(event);
    });
    
    // ì›”ë³„ ì¸ë±ìŠ¤ ìƒì„±
    const monthIndex = {};
    calendarData.events.forEach(event => {
      const monthKey = `${event.year}-${String(event.monthNumber).padStart(2, '0')}`;
      if (!monthIndex[monthKey]) {
        monthIndex[monthKey] = [];
      }
      monthIndex[monthKey].push(event);
    });
    
    // ì¸ë±ìŠ¤ íŒŒì¼ ì €ì¥
    const indexData = {
      byDate: dateIndex,
      byMonth: monthIndex,
      generatedAt: new Date().toISOString()
    };
    
    const indexPath = path.resolve(process.cwd(), "assets", "í•™ì‚¬ì¼ì •_ì¸ë±ìŠ¤.json");
    await fs.writeFile(indexPath, JSON.stringify(indexData, null, 2), "utf-8");
    
    console.log(`ğŸ“š ì¸ë±ìŠ¤ íŒŒì¼ ìƒì„±: ${indexPath}`);
    
  } catch (error) {
    console.error("âŒ ì¸ë±ìŠ¤ ìƒì„± ì‹¤íŒ¨:", error.message);
  }
}

// ì‹¤í–‰
async function main() {
  await parseCalendarToJson();
  await generateHelperFunctions();
}

// ëª¨ë“ˆë¡œ export (ë‹¤ë¥¸ íŒŒì¼ì—ì„œ ì‚¬ìš© ê°€ëŠ¥)
module.exports = {
  parseCalendarToJson,
  generateHelperFunctions
};

// ì§ì ‘ ì‹¤í–‰ ì‹œ
if (require.main === module) {
  main().catch(console.error);
}
