require("module-alias/register");

const axios = require("axios");
const cheerio = require("cheerio");
const fs = require("fs-extra");
const path = require("path");
const pool = require("@root/utils/db");
const logger = require("@root/utils/logger");

const BASE_URL = "https://happydorm.hoseo.ac.kr";
const DOWNLOAD_ROOT = path.resolve(process.cwd(), "download_happy_dorm");
const headers = {
  "User-Agent":
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " +
    "AppleWebKit/537.36 (KHTML, like Gecko) " +
    "Chrome/124.0.0.0 Safari/537.36",
  Accept: "*/*",
  Referer: BASE_URL + "/",
};

// íŒŒì¼ëª… ì•ˆì „ ë³€í™˜ í•¨ìˆ˜
function safeFilename(name, fallbackExt = ".bin") {
  if (!name || name.trim() === "") {
    return `file_${Date.now()}${fallbackExt}`;
  }

  let ext = path.extname(name);
  if (!ext) ext = fallbackExt;

  let base = name.replace(/[\\/:*?"<>|]+/g, "_").trim();
  if (!base.endsWith(ext)) base += ext;

  return base;
}

// íŒŒì¼ ë‹¤ìš´ë¡œë“œ í•¨ìˆ˜
async function downloadFile(fileUrl, destPath) {
  if (fileUrl.startsWith("/")) {
    fileUrl = BASE_URL + fileUrl;
  }

  const writer = fs.createWriteStream(destPath);
  const response = await axios({
    url: fileUrl,
    method: "GET",
    responseType: "stream",
    headers,
  });

  response.data.pipe(writer);

  return new Promise((resolve, reject) => {
    writer.on("finish", resolve);
    writer.on("error", reject);
  });
}

// íŒŒì¼ ë‹¤ìš´ë¡œë“œ + DB ì €ì¥
async function downloadFileAndSaveDB(menuNum, fileType, fileUrl, originName, downloadDir) {
  const filenameSafe = safeFilename(originName, fileType === "image" ? ".jpg" : ".pdf");
  const localFilePath = path.join(downloadDir, filenameSafe);
  const relativeFilePath = path.relative(process.cwd(), localFilePath);

  // URLìš© ê²½ë¡œ (ìŠ¬ë˜ì‹œë¡œ ë³€í™˜)
  const urlPath = relativeFilePath.replace(/\\/g, "/");

  // íŒŒì¼ ë‹¤ìš´ë¡œë“œ
  await downloadFile(fileUrl, localFilePath);

  // DB ì €ì¥(tbl_menufile) - í–‰ë³µê¸°ìˆ™ì‚¬ìš© í…Œì´ë¸”ëª… ìˆ˜ì • í•„ìš”ì‹œ ë³€ê²½
  await pool.execute(
    `INSERT INTO tbl_menufile (menu_num, file_type, file_name, origin_name, file_path, file_url)
     VALUES (?, ?, ?, ?, ?, ?)
     ON DUPLICATE KEY UPDATE 
     file_type = VALUES(file_type),
     file_name = VALUES(file_name),
     origin_name = VALUES(origin_name),
     file_path = VALUES(file_path),
     file_url = VALUES(file_url)`,
    [menuNum, fileType, filenameSafe, originName, urlPath, fileUrl]
  );

  return {
    filename: filenameSafe,
    localpath: urlPath,
    fullPath: localFilePath,
  };
}

// ì²¨ë¶€íŒŒì¼ ì²˜ë¦¬ í•¨ìˆ˜ (í–‰ë³µê¸°ìˆ™ì‚¬ API ë°©ì‹)
async function processAttachments(idx, downloadDir) {
  const attachments = [];

  try {
    // í–‰ë³µê¸°ìˆ™ì‚¬ì˜ ì²¨ë¶€íŒŒì¼ API í˜¸ì¶œ
    const fileApiUrl = `${BASE_URL}/fileload?idx=${idx}&table=board&rev=4`;
    const response = await axios.get(fileApiUrl, { headers });
    const fileData = response.data;

    if (Array.isArray(fileData) && fileData.length > 0) {
      const downloadPromises = [];

      for (const file of fileData) {
        const fileUrl = file.file_url;
        const originName = file.file_original_name;

        attachments.push({
          originUrl: fileUrl,
          originName: originName,
          localPath: null,
          fileName: null,
        });

        downloadPromises.push(
          downloadFileAndSaveDB(idx, "attachment", fileUrl, originName, downloadDir)
            .then((result) => {
              // attachments ë°°ì—´ì˜ í•´ë‹¹ í•­ëª© ì—…ë°ì´íŠ¸
              const attachmentIndex = attachments.findIndex((att) => att.originUrl === fileUrl);
              if (attachmentIndex !== -1) {
                attachments[attachmentIndex].localPath = result.localpath;
                attachments[attachmentIndex].fileName = result.filename;
              }
            })
            .catch((e) => {
              console.error(`[${idx}] ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜ (${originName}):`, e.message);
            })
        );
      }

      await Promise.all(downloadPromises);
    }
  } catch (err) {
    console.warn(`[${idx}] ì²¨ë¶€íŒŒì¼ API í˜¸ì¶œ ì‹¤íŒ¨:`, err.message);
  }

  return attachments;
}

// ì´ë¯¸ì§€ ì²˜ë¦¬ í•¨ìˆ˜ (í–‰ë³µê¸°ìˆ™ì‚¬ íŠ¹ìˆ˜ URL ì²˜ë¦¬)
async function processImages($, boardElement, idx, downloadDir) {
  const imagePromises = [];
  const assets = [];
  let imageIndex = 0;

  boardElement.find("img").each((i, el) => {
    const $img = $(el);
    let src = $img.attr("src");

    if (!src) return;

    imageIndex++;

    // í–‰ë³µê¸°ìˆ™ì‚¬ ì´ë¯¸ì§€ URL ì²˜ë¦¬ (/api/image/imgdownload?hash=...)
    let filename;
    if (src.includes("/api/image/imgdownload")) {
      // hash ê°’ì—ì„œ íŒŒì¼ëª… ìƒì„±
      const hashMatch = src.match(/hash=([a-f0-9]+)/);
      const idxMatch = src.match(/idx=(\d+)/);
      if (hashMatch && idxMatch) {
        filename = `image_${idxMatch[1]}_${hashMatch[1].substring(0, 8)}.jpg`;
      } else {
        filename = `image_${imageIndex}.jpg`;
      }
    } else {
      // ì¼ë°˜ ì´ë¯¸ì§€ URL ì²˜ë¦¬
      const baseName = path.basename(src.split("?")[0]);
      filename = safeFilename(baseName || `image_${imageIndex}.jpg`, ".jpg");
    }

    const fileUrl = src.startsWith("/") ? BASE_URL + src : src;

    // ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ë° DB ì €ì¥
    imagePromises.push(
      downloadFileAndSaveDB(idx, "image", fileUrl, filename, downloadDir)
        .then((result) => {
          // img src ê²½ë¡œë¥¼ ë¡œì»¬ íŒŒì¼ëª…ìœ¼ë¡œ ë³€ê²½
          $img.attr("src", result.filename);

          // assets ë°°ì—´ì— ì¶”ê°€
          assets.push({
            localPath: result.localpath,
            fileName: result.filename,
          });
        })
        .catch((e) => {
          console.error(`[${idx}] ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì˜¤ë¥˜ (${filename}):`, e.message);
        })
    );
  });

  await Promise.all(imagePromises);
  return assets;
}

// ë©”ë‰´ ë‹¤ìš´ë¡œë“œ ìƒíƒœ ì—…ë°ì´íŠ¸
async function updateMenuDownloadStatus(idx, isSuccess, errorMessage = null) {
  try {
    await pool.execute(
      `UPDATE TBL_Menu 
       SET download_completed = ?, 
           download_date = NOW(),
           download_error = ?
       WHERE chidx = ? AND type = 'HAPPY_DORM_NUTRITION'`,
      [isSuccess ? 1 : 0, errorMessage, idx]
    );
  } catch (e) {
    logger.error(`DB ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ [${idx}]: ${e.message}`);
  }
}

// í†µí•© ë©”ë‰´ ì²˜ë¦¬ í•¨ìˆ˜
async function parseAndSaveHappyDormMenu(idx) {
  try {
    const url = `${BASE_URL}/board/nutrition/view?idx=${idx}`;
    console.log(`[${idx}] ìš”ì²­ URL: ${url}`);

    const { data: html } = await axios.get(url, { headers });
    console.log(`[${idx}] ì‘ë‹µ ë°›ìŒ - HTML ê¸¸ì´: ${html.length}ë°”ì´íŠ¸`);

    const $ = cheerio.load(html);

    // í˜ì´ì§€ ê¸°ë³¸ ì •ë³´ ì¶œë ¥
    const pageTitle = $("title").text();
    console.log(`[${idx}] í˜ì´ì§€ ì œëª©: "${pageTitle}"`);

    // ì—ëŸ¬ í˜ì´ì§€ì¸ì§€ í™•ì¸ (ë” ì •í™•í•œ ì¡°ê±´ìœ¼ë¡œ ìˆ˜ì •)
    if (
      html.includes("404 Not Found") ||
      html.includes("Page not found") ||
      pageTitle.includes("404") ||
      pageTitle.includes("Not Found") ||
      html.includes("<h1>404</h1>") ||
      html.includes("HTTP 404")
    ) {
      console.log(`[${idx}] âŒ 404 ì—ëŸ¬ í˜ì´ì§€ë¡œ ë³´ì„`);
      throw new Error("404 í˜ì´ì§€");
    }

    console.log(`[${idx}] HTML êµ¬ì¡° ë¶„ì„ ì‹œì‘...`);

    // í–‰ë³µê¸°ìˆ™ì‚¬ ë³¸ë¬¸ ì˜ì—­ ì¶”ì¶œ (ì—¬ëŸ¬ ì„ íƒì ì‹œë„)
    const possibleSelectors = [
      ".board_view", // ì‹¤ì œ ë‚´ìš©ì´ ìˆëŠ” í´ë˜ìŠ¤ (ì–¸ë”ìŠ¤ì½”ì–´)
      ".board-view", // í•˜ì´í”ˆ ë²„ì „
      ".board-content", // ê¸°ì¡´ ì‹œë„í–ˆë˜ í´ë˜ìŠ¤
      ".content",
      ".view-content",
      ".post-content",
      ".article-content",
      ".detail-content",
      ".nutrition-content",
      ".board-detail",
      ".view-area",
      ".content-area",
      ".main-content",
      "#content",
      "#board-content",
      ".board_content",
      ".view_content",
    ];

    let boardContent = null;
    let usedSelector = null;

    // ê° ì„ íƒìë¥¼ ì‹œë„í•´ì„œ ìœ íš¨í•œ ë‚´ìš©ì´ ìˆëŠ” ìš”ì†Œ ì°¾ê¸°
    for (const selector of possibleSelectors) {
      const element = $(selector);
      if (element.length > 0 && element.html() && element.text().trim()) {
        boardContent = element;
        usedSelector = selector;
        console.log(`[${idx}] ë³¸ë¬¸ ì˜ì—­ ë°œê²¬: ${selector}`);
        break;
      }
    }

    // íŠ¹ì • ì„ íƒìë¡œë„ ëª» ì°¾ìœ¼ë©´ div íƒœê·¸ ì¤‘ì—ì„œ í…ìŠ¤íŠ¸ê°€ ë§ì€ ê²ƒ ì°¾ê¸°
    if (!boardContent) {
      console.log(`[${idx}] ê¸°ë³¸ ì„ íƒìë¡œ ë³¸ë¬¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ. ëŒ€ì•ˆ ë°©ë²• ì‹œë„...`);

      // 1. ëª¨ë“  div ìš”ì†Œ ì¤‘ì—ì„œ ê°€ì¥ ê¸´ í…ìŠ¤íŠ¸ ì°¾ê¸°
      let bestDiv = null;
      let maxTextLength = 0;

      $("div").each((i, el) => {
        const $div = $(el);
        const text = $div.text().trim();
        if (text.length > maxTextLength && text.length > 50) {
          maxTextLength = text.length;
          bestDiv = $div;
        }
      });

      if (bestDiv && maxTextLength > 100) {
        boardContent = bestDiv;
        usedSelector = "div (ìµœëŒ€ í…ìŠ¤íŠ¸)";
        console.log(`[${idx}] ê°€ì¥ ê¸´ í…ìŠ¤íŠ¸ë¥¼ ê°€ì§„ div ì‚¬ìš© (${maxTextLength}ì)`);
      }

      // 2. ê·¸ë˜ë„ ì—†ìœ¼ë©´ body íƒœê·¸ ì „ì²´ ì‚¬ìš©
      if (!boardContent) {
        const bodyContent = $("body");
        if (bodyContent.length > 0 && bodyContent.text().trim().length > 100) {
          boardContent = bodyContent;
          usedSelector = "body (ì „ì²´)";
          console.log(`[${idx}] body íƒœê·¸ ì „ì²´ ì‚¬ìš© (${bodyContent.text().trim().length}ì)`);
        }
      }

      // 3. ë§ˆì§€ë§‰ìœ¼ë¡œ main, article, section íƒœê·¸ ì‹œë„
      if (!boardContent) {
        const alternativeTags = ["main", "article", "section"];
        for (const tag of alternativeTags) {
          const element = $(tag);
          if (element.length > 0 && element.text().trim().length > 50) {
            boardContent = element;
            usedSelector = tag;
            console.log(`[${idx}] ${tag} íƒœê·¸ ì‚¬ìš© (${element.text().trim().length}ì)`);
            break;
          }
        }
      }
    }

    if (!boardContent || !boardContent.html() || !boardContent.text().trim()) {
      // ë””ë²„ê¹… ì •ë³´ ì¶œë ¥
      console.log(`[${idx}] HTML êµ¬ì¡° ë””ë²„ê¹…:`);
      console.log(`  - í˜ì´ì§€ ì œëª©: ${$("title").text()}`);
      console.log(`  - HTML ê¸¸ì´: ${html.length}`);
      console.log(`  - div ê°œìˆ˜: ${$("div").length}`);
      console.log(`  - p ê°œìˆ˜: ${$("p").length}`);
      console.log(`  - article ê°œìˆ˜: ${$("article").length}`);
      console.log(`  - section ê°œìˆ˜: ${$("section").length}`);
      console.log(`  - main ê°œìˆ˜: ${$("main").length}`);

      // í´ë˜ìŠ¤ëª… ì¶œë ¥
      const classes = new Set();
      $("*[class]").each((i, el) => {
        const classList = $(el).attr("class").split(" ");
        classList.forEach((cls) => {
          if (cls.trim()) classes.add(cls.trim());
        });
      });

      const relevantClasses = Array.from(classes).filter(
        (cls) =>
          cls.includes("content") ||
          cls.includes("board") ||
          cls.includes("view") ||
          cls.includes("post") ||
          cls.includes("article") ||
          cls.includes("nutrition")
      );
      console.log(`  - ê´€ë ¨ í´ë˜ìŠ¤: ${relevantClasses.join(", ")}`);

      // ID ì¶œë ¥
      const ids = [];
      $("*[id]").each((i, el) => {
        const id = $(el).attr("id");
        if (id) ids.push(id);
      });
      console.log(`  - ëª¨ë“  ID: ${ids.join(", ")}`);

      // HTML ë‚´ìš© ì¼ë¶€ ì¶œë ¥ (ë””ë²„ê¹…ìš©)
      console.log(`  - HTML ì‹œì‘ ë¶€ë¶„ (500ì):`);
      console.log(html.substring(0, 500));
      console.log(`  - HTML ë ë¶€ë¶„ (500ì):`);
      console.log(html.substring(html.length - 500));

      logger.warn(`ë³¸ë¬¸ ì˜ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ [${idx}]`);
      await updateMenuDownloadStatus(idx, false, "ë³¸ë¬¸ ì˜ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ");
      throw new Error("ë³¸ë¬¸ ì˜ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
    }

    console.log(`[${idx}] ì‚¬ìš©ëœ ì„ íƒì: ${usedSelector}`);

    logger.info(`ğŸ“¥ í–‰ë³µê¸°ìˆ™ì‚¬ ì²˜ë¦¬ ì‹œì‘ [${idx}]`);

    // ì €ì¥ ë””ë ‰í† ë¦¬ ìƒì„±
    const menuDownloadDir = path.join(DOWNLOAD_ROOT, String(idx));
    await fs.ensureDir(menuDownloadDir);

    // ì²¨ë¶€íŒŒì¼ ì²˜ë¦¬ (API ë°©ì‹)
    console.log(`[${idx}] ì²¨ë¶€íŒŒì¼ ì²˜ë¦¬ ì¤‘...`);
    const attachments = await processAttachments(idx, menuDownloadDir);

    // ì´ë¯¸ì§€ ì²˜ë¦¬ (HTML ìˆ˜ì • í¬í•¨)
    console.log(`[${idx}] ì´ë¯¸ì§€ ì²˜ë¦¬ ì¤‘...`);
    const assets = await processImages($, boardContent, idx, menuDownloadDir);

    // HTML íŒŒì¼ ì €ì¥ (ìˆ˜ì •ëœ ì´ë¯¸ì§€ ê²½ë¡œ í¬í•¨)
    const htmlFilePath = path.join(menuDownloadDir, `${idx}.html`);
    await fs.writeFile(htmlFilePath, boardContent.html(), {
      encoding: "utf-8",
    });

    // JSON ë©”íƒ€ë°ì´í„° ì €ì¥
    const jsonResult = {
      idx: idx,
      type: "HAPPY_DORM_NUTRITION",
      content: `download_happy_dorm/${idx}/${idx}.html`,
      assets: assets,
      attachments: attachments,
    };

    const jsonFilePath = path.join(menuDownloadDir, `${idx}_detail.json`);
    await fs.writeFile(jsonFilePath, JSON.stringify(jsonResult, null, 2), "utf-8");

    // DBì— ì™„ë£Œ ìƒíƒœ ì—…ë°ì´íŠ¸
    await updateMenuDownloadStatus(idx, true);

    console.log(`[${idx}] âœ… ì™„ë£Œ: HTML(${assets.length}ê°œ ì´ë¯¸ì§€), JSON, ${attachments.length}ê°œ ì²¨ë¶€íŒŒì¼, DB ì €ì¥`);

    return jsonResult;
  } catch (err) {
    console.error(`[${idx}] âŒ ì—ëŸ¬:`, err.message);
    // ì‹¤íŒ¨ ìƒíƒœë„ DBì— ê¸°ë¡
    await updateMenuDownloadStatus(idx, false, err.message);
    throw err;
  }
}

// í–‰ë³µê¸°ìˆ™ì‚¬ ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜
async function runHappyDormDetailScraper() {
  try {
    // DBì—ì„œ ì•„ì§ ë‹¤ìš´ë¡œë“œë˜ì§€ ì•Šì€ í–‰ë³µê¸°ìˆ™ì‚¬ ë©”ë‰´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
    const sql = `
      SELECT chidx FROM TBL_Menu 
      WHERE type = 'HAPPY_DORM_NUTRITION' 
        AND (download_completed IS NULL OR download_completed = 0)
      ORDER BY chidx DESC 
      LIMIT 10
    `;

    const [result] = await pool.query(sql);
    const menuList = result.map((r) => r.chidx);

    console.log(`ì´ ${menuList.length}ê°œì˜ í–‰ë³µê¸°ìˆ™ì‚¬ ë©”ë‰´ë¥¼ ì²˜ë¦¬í•©ë‹ˆë‹¤.`);

    if (menuList.length === 0) {
      console.log("ì²˜ë¦¬í•  í–‰ë³µê¸°ìˆ™ì‚¬ ë©”ë‰´ê°€ ì—†ìŠµë‹ˆë‹¤.");
      return;
    }

    // ë©”ë‰´ë³„ë¡œ ìƒì„¸ í¬ë¡¤ë§/íŒŒì‹±
    let successCount = 0;
    let failCount = 0;

    for (const idx of menuList) {
      try {
        await parseAndSaveHappyDormMenu(idx);
        successCount++;

        // ìš”ì²­ ê°„ê²© ì¡°ì ˆ (ì„œë²„ ë¶€í•˜ ë°©ì§€)
        await new Promise((resolve) => setTimeout(resolve, 1000));
      } catch (e) {
        console.error(`âŒ idx=${idx} ì²˜ë¦¬ ì‹¤íŒ¨:`, e.message);
        failCount++;
      }
    }

    console.log(`\n=== í–‰ë³µê¸°ìˆ™ì‚¬ ì²˜ë¦¬ ì™„ë£Œ ===`);
    console.log(`ì„±ê³µ: ${successCount}ê°œ`);
    console.log(`ì‹¤íŒ¨: ${failCount}ê°œ`);
    console.log(`ì´ê³„: ${successCount + failCount}ê°œ`);
  } catch (error) {
    console.error("í–‰ë³µê¸°ìˆ™ì‚¬ ë©”ì¸ í”„ë¡œì„¸ìŠ¤ ì˜¤ë¥˜:", error);
  }
}

// ì§ì ‘ ì‹¤í–‰ë  ë•Œë§Œ ë©”ì¸ í•¨ìˆ˜ í˜¸ì¶œ
if (require.main === module) {
  (async () => {
    try {
      await runHappyDormDetailScraper();
    } catch (err) {
      console.error("âŒ ì „ì²´ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜:", err.message);
    } finally {
      pool.end();
    }
  })();
}

// export for use in other modules
module.exports = {
  parseAndSaveHappyDormMenu,
  runHappyDormDetailScraper,
};

